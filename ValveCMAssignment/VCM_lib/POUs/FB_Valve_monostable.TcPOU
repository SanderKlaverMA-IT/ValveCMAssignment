<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="FB_Valve_monostable" Id="{1cd6c90b-c4e4-4d82-bc3a-27baa17871c6}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_Valve_monostable
VAR_INPUT
	MaxOpenCloseDuration: INT; //(s) Maximum time the valve needs to open or close in seconds
END_VAR
VAR_OUTPUT
	setOpen: BOOL;
END_VAR
VAR_IN_OUT
	Valve: DUT_VALVE;
	I_O: DUT_IO;
END_VAR
VAR
	openingTimer: Tc2_Standard.TON;
	closingTimer: Tc2_Standard.TON;
	fbHmiDut: FB_DUT_HMI; 
	manualOpen: BOOL;
	manualClose: BOOL;
	manualReset: BOOL;
	reqOpen: BOOL;
	reqClose: BOOL;
	isOpen: BOOL;
	isClosed: BOOL;
	startOpeningTimeOut: BOOL;
	startClosingTimeOut: BOOL;
	fbDutHmi: FB_DUT_HMI;
	
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[{region Input} 
//set INTERNAL variables
// hmi-open command
IF Valve.Hmi.Open THEN
	manualOpen := TRUE;
	Valve.Hmi.Open := FALSE;
END_IF

// hmi-close command
IF Valve.Hmi.Close THEN
	manualClose := TRUE;
	Valve.Hmi.Close := FALSE;
END_IF

// manual_reset command
IF Valve.Hmi.Reset OR manualReset THEN
	manualReset := TRUE;
	Valve.Hmi.Reset := FALSE;
END_IF 			

// Created Utitlities FB's for learning, can also use altenative (simplefied) code here  
// tried to avoid redunant (HMI) logic.
fbDutHmi(hmiValue_in:= Valve.Hmi);
Valve.Hmi := fbDutHmi.hmiValue_out;
	 
//Set HMI modus overide HMI by CS
Valve.Hmi.DisableAutoManual := Valve.Cs.ManualOn OR Valve.Cs.AutoOn;
IF Valve.Cs.ManualOn THEN
	Valve.Hmi.ManualOn := TRUE;
	Valve.Hmi.ManualOff := FALSE;
	Valve.Hmi.AutoOn := FALSE;
	Valve.Hmi.AutoOff := FALSE;
	Valve.Hmi.ModeValue := 0;
END_IF

IF Valve.Cs.AutoOn THEN
	Valve.Hmi.ManualOn := FALSE;
	Valve.Hmi.ManualOff := FALSE;
	Valve.Hmi.AutoOn := TRUE;
	Valve.Hmi.AutoOff := FALSE;
	Valve.Hmi.ModeValue := 1;
END_IF
	  
{endregion input}
	 

{region interlock-manual-auto}
Valve.Sts.InSimulation := Valve.Cs.Simulation OR Valve.Hmi.Simulation; 
Valve.Sts.Interlock := Valve.Cs.Interlock;

// Set Auto/Manual mode
// CS is Dominant over HMI
Valve.Sts.ManualMode S= (Valve.Cs.Manual OR Valve.Hmi.ManualOn) AND NOT(Valve.Cs.Auto);
Valve.Sts.ManualMode R= (Valve.Cs.Auto OR Valve.Hmi.AutoOn) AND NOT(Valve.Cs.Manual);
Valve.Sts.AutoMode:= NOT(Valve.Sts.ManualMode);
{endregion interlock manual auto}

{region control coördination} 
              
// determine the actual or required state
reqOpen S= (Valve.Sts.AutoMode AND Valve.Cs.Open) OR (Valve.Sts.ManualMode AND manualOpen);
reqOpen R= isOpen;
reqClose S= Valve.Sts.Interlock OR (Valve.Sts.AutoMode AND Valve.Cs.Close) OR (Valve.Sts.ManualMode AND manualClose);
reqClose R= isClosed;
isOpen S= I_O.I_isOpen OR (Valve.Sts.InSimulation AND reqOpen);
isOpen R= NOT (I_O.I_isOpen);	 
isClosed S= I_O.I_isClosed OR (Valve.Sts.InSimulation AND reqClose);
isClosed R= NOT (I_O.I_isClosed);

// set state
IF reqClose THEN
    Valve.Sts.State := GVL_VCM.STS_CLOSING;
ELSIF reqOpen THEN
    Valve.Sts.State := GVL_VCM.STS_OPENING;
ELSIF isOpen THEN
    Valve.Sts.State := GVL_VCM.STS_OPEN;
ELSIF isClosed THEN
    Valve.Sts.State := GVL_VCM.STS_CLOSED;


END_IF

// INIT STS.State zet to CLOSING if UNDEFINED
IF Valve.Sts.State = GVL_VCM.STS_UNDEFINED THEN
	Valve.Sts.State := GVL_VCM.STS_CLOSING;		 
END_IF
		  
CASE Valve.Sts.State OF
    10: //isClosed
        Valve.Sts.Closed := TRUE;
        Valve.Sts.Opening := FALSE;
        Valve.Sts.Open := FALSE;
        Valve.Sts.Closing := FALSE;
    20: //opening
        Valve.Sts.Closed := FALSE;
        Valve.Sts.Opening := TRUE;
        Valve.Sts.Open := FALSE;
        Valve.Sts.Closing := FALSE;
    30: // isOpen
        Valve.Sts.Closed := FALSE;
        Valve.Sts.Opening := FALSE;
        Valve.Sts.Open := TRUE;
        Valve.Sts.Closing := FALSE;
    40: // closing
        Valve.Sts.Closed := FALSE;
        Valve.Sts.Opening := FALSE;
        Valve.Sts.Open := FALSE;
        Valve.Sts.Closing := TRUE;
END_CASE

{endregion}

{region set timer guard for opening and closing}
// Don't use the same timer for opening or closing in case opening or closing is called while previous opening or closing action isn't finished yet.
// Can only be done if a 'DirectionChanged' variable is used. 
//opening timeout guard
startOpeningTimeOut S= NOT (Valve.Sts.Interlock) AND Valve.Sts.Opening;
startOpeningTimeOut R= Valve.Sts.Open OR Valve.Sts.Closing;
openingTimer(IN := startOpeningTimeOut, PT:= INT_TO_TIME(MaxOpenCloseDuration * 1000));
//closing timeout guard
startClosingTimeOut S= Valve.Sts.Interlock OR Valve.Sts.Closing;
startClosingTimeOut R= Valve.Sts.Closed OR Valve.Sts.Opening;
closingTimer(IN := startClosingTimeOut, PT:= INT_TO_TIME(MaxOpenCloseDuration * 1000));

{endregion}

{region Handle alarms}
IF Valve.Cs.Reset OR manualReset THEN
	//reset inAlarm only demand
    Valve.Alm.InAlarm := FALSE;
END_IF
// check if failure (still) exist.
Valve.Alm.TimeFailure := openingTimer.Q OR closingTimer.Q; // Set TimeFailure on opening or closing timeOut
Valve.Alm.GeneralFailure := I_O.I_hasFailure; // Set GeneralFailure
Valve.Alm.InAlarm := Valve.Alm.GeneralFailure OR Valve.Alm.TimeFailure OR Valve.Alm.InAlarm;
{endregion}

{region outputs}
// set/reset output (O_setOpen)
I_O.O_setOpen S= (Valve.Sts.Opening OR Valve.Sts.Open); //Warning: Valve is monostable, keep output also open on status: Valve.Sts.Open
I_O.O_setOpen R= Valve.Sts.Closing OR Valve.Sts.Interlock OR Valve.Sts.InSimulation;

{endregion}

{region cleanup state}
	manualClose R= TRUE;
	manualOpen R= TRUE;
	manualReset R= TRUE;
{endregion}
]]></ST>
    </Implementation>
    <LineIds Name="FB_Valve_monostable">
      <LineId Id="1490" Count="0" />
      <LineId Id="1732" Count="0" />
      <LineId Id="1492" Count="16" />
      <LineId Id="1773" Count="2" />
      <LineId Id="1784" Count="0" />
      <LineId Id="1525" Count="0" />
      <LineId Id="1783" Count="0" />
      <LineId Id="1526" Count="19" />
      <LineId Id="1733" Count="0" />
      <LineId Id="1546" Count="13" />
      <LineId Id="1694" Count="1" />
      <LineId Id="1561" Count="1" />
      <LineId Id="1696" Count="2" />
      <LineId Id="1567" Count="2" />
      <LineId Id="1702" Count="0" />
      <LineId Id="1701" Count="0" />
      <LineId Id="1692" Count="0" />
      <LineId Id="1691" Count="0" />
      <LineId Id="1704" Count="0" />
      <LineId Id="1703" Count="0" />
      <LineId Id="1699" Count="1" />
      <LineId Id="1572" Count="0" />
      <LineId Id="1578" Count="32" />
      <LineId Id="1683" Count="0" />
      <LineId Id="1686" Count="0" />
      <LineId Id="1688" Count="0" />
      <LineId Id="1661" Count="0" />
      <LineId Id="1612" Count="2" />
      <LineId Id="1659" Count="0" />
      <LineId Id="1657" Count="1" />
      <LineId Id="1656" Count="0" />
      <LineId Id="1615" Count="1" />
      <LineId Id="1623" Count="0" />
      <LineId Id="1672" Count="0" />
      <LineId Id="1678" Count="0" />
      <LineId Id="1682" Count="0" />
      <LineId Id="1679" Count="0" />
      <LineId Id="1675" Count="0" />
      <LineId Id="1669" Count="0" />
      <LineId Id="1666" Count="0" />
      <LineId Id="1634" Count="1" />
      <LineId Id="1638" Count="2" />
      <LineId Id="1642" Count="2" />
      <LineId Id="1649" Count="5" />
      <LineId Id="1681" Count="0" />
      <LineId Id="1655" Count="0" />
      <LineId Id="36" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>