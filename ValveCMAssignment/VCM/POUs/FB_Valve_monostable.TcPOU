<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="FB_Valve_monostable" Id="{960a4f6f-ad56-4762-b13b-5efd91056808}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_Valve_monostable
VAR_INPUT
	MaxOpenCloseDuration: INT; //(s) Maximum time the valve needs to open or close in seconds
END_VAR
VAR_OUTPUT
	setOpen: BOOL;
END_VAR
VAR_IN_OUT
	Valve: DUT_VALVE;
END_VAR
VAR
	opening_closing_timer: Tc2_Standard.TON;
	manualOpen: BOOL;
	manualClose: BOOL;
	manualReset: BOOL;
	reqOpen: BOOL;
	reqClose: BOOL;
	isOpen: BOOL;
	isClosed: BOOL;
	STS: INT;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[{region Input} //set INTERNAL variables

//// hmi-open command
//IF Valve.Hmi.Open THEN
//	manualOpen := TRUE;
//	Valve.Hmi.Open := FALSE;
//END_IF
	 
//// hmi-close command
//IF Valve.Hmi.Close THEN
//	manualClose := TRUE;
//	Valve.Hmi.Close := FALSE;
//END_IF
	
// manual_reset command
IF Valve.Hmi.Reset OR manualReset THEN
	manualReset := TRUE;
	Valve.Hmi.Reset := FALSE;
END_IF 			
manualOpen := Valve.Hmi.Open;
manualClose := Valve.Hmi.Close;


// waar hoort deze code/logica, is Hmi logica kan niet in de struct ?? FB van maken ?
CASE Valve.Hmi.ModeValue OF
    0: // Manual
        Valve.Hmi.ManualOn := TRUE;
        Valve.Hmi.ManualOff := FALSE;
        Valve.Hmi.AutoOn := FALSE;
        Valve.Hmi.AutoOff := FALSE;
    1: // Auto
        Valve.Hmi.ManualOn := FALSE;
        Valve.Hmi.ManualOff := FALSE;
        Valve.Hmi.AutoOn := TRUE;
        Valve.Hmi.AutoOff := FALSE;
END_CASE  
{endregion}
	 
{region interlock manual auto}
Valve.Sts.InSimulation := Valve.Cs.Simulation OR Valve.Hmi.Simulation; 
Valve.Sts.Interlock := Valve.Cs.Interlock;
Valve.Sts.ManualMode := NOT Valve.Sts.Interlock AND (Valve.Cs.Manual OR Valve.Hmi.ManualOn);
Valve.Sts.AutoMode := NOT (Valve.Sts.Interlock OR Valve.Sts.ManualMode) AND (Valve.Cs.Manual OR Valve.Hmi.ManualOn);
{endregion}

{region control coördination}

IF manualReset THEN
    Valve.Alm.GeneralFailure := FALSE;
    Valve.Alm.TimeFailure := FALSE;
END_IF
     
IF GVL_VCM.io_values.I_hasFailure THEN
    Valve.Alm.GeneralFailure := TRUE;
    RETURN;		 
END_IF
               
reqOpen := (Valve.Sts.AutoMode AND Valve.Cs.Open) OR (Valve.Sts.ManualMode AND manualOpen);
reqClose := Valve.Sts.Interlock OR (Valve.Sts.AutoMode AND Valve.Cs.Close) OR (Valve.Sts.ManualMode AND manualClose);
isOpen := GVL_VCM.io_values.I_isOpen OR (Valve.Sts.InSimulation AND reqOpen);
isClosed := GVL_VCM.io_values.I_isClosed OR (Valve.Sts.InSimulation AND reqClose);

// set state
IF isClosed THEN
    Valve.Sts.State := 10;
ELSIF reqOpen THEN
    Valve.Sts.State := 20;
ELSIF isOpen THEN
    Valve.Sts.State := 30;
ELSIF reqClose THEN
    Valve.Sts.State := 40;
END_IF

CASE Valve.Sts.State OF
    10: //isClosed 
        Valve.Sts.Closed := TRUE;
        Valve.Sts.Opening := FALSE;
        Valve.Sts.Open := FALSE;
        Valve.Sts.Closing := FALSE;
    20: //opening
         Valve.Sts.Closed := FALSE;
        Valve.Sts.Opening := TRUE;
        Valve.Sts.Open := FALSE;
        Valve.Sts.Closing := FALSE;
    30: // isOpen
         Valve.Sts.Closed := FALSE;
        Valve.Sts.Opening := FALSE;
        Valve.Sts.Open := TRUE;
        Valve.Sts.Closing := FALSE;
    40: // closing
         Valve.Sts.Closed := FALSE;
        Valve.Sts.Opening := FALSE;
        Valve.Sts.Open := FALSE;
        Valve.Sts.Closing := TRUE;
END_CASE

{endregion}

{region set timer guard for opening and closing}

opening_closing_timer(IN := (Valve.Sts.Opening OR Valve.Sts.Closing), PT:= INT_TO_TIME(MaxOpenCloseDuration * 1000));
Valve.Alm.TimeFailure := opening_closing_timer.Q;
{endregion}

{region reset transient state values}
// TODO, denk na over hoe de transient state weer te resetten???
// is de transient state wel nodig?
//manualOpen := FALSE;
//manualClose := FALSE;
//manualReset := FALSE;
{endregion}
 
{region BasicControls}
IF manualReset THEN
    Valve.Alm.InAlarm := FALSE;
    manualReset := FALSE;
END_IF

Valve.Alm.InAlarm := (Valve.Alm.InAlarm) OR (Valve.Alm.GeneralFailure) OR (Valve.Alm.TimeFailure);
GVL_VCM.io_values.O_setOpen := NOT Valve.Sts.InSimulation AND reqOpen;
 
{endregion}

{region outputs}


//TODO remove after debugging
//begin used for debugging to read the values ond end of the cyclus: 
    Valve.Sts.State := Valve.Sts.State;
// used for debugging
{endregion}
]]></ST>
    </Implementation>
    <LineIds Name="FB_Valve_monostable">
      <LineId Id="953" Count="18" />
      <LineId Id="1088" Count="0" />
      <LineId Id="1087" Count="0" />
      <LineId Id="1086" Count="0" />
      <LineId Id="1073" Count="0" />
      <LineId Id="1053" Count="0" />
      <LineId Id="972" Count="0" />
      <LineId Id="1055" Count="1" />
      <LineId Id="1067" Count="0" />
      <LineId Id="1057" Count="0" />
      <LineId Id="1068" Count="0" />
      <LineId Id="1060" Count="1" />
      <LineId Id="1069" Count="1" />
      <LineId Id="1062" Count="0" />
      <LineId Id="1054" Count="0" />
      <LineId Id="973" Count="39" />
      <LineId Id="1074" Count="2" />
      <LineId Id="1013" Count="0" />
      <LineId Id="1077" Count="2" />
      <LineId Id="1014" Count="1" />
      <LineId Id="1080" Count="2" />
      <LineId Id="1016" Count="1" />
      <LineId Id="1083" Count="2" />
      <LineId Id="1018" Count="19" />
      <LineId Id="1089" Count="0" />
      <LineId Id="1091" Count="0" />
      <LineId Id="1093" Count="0" />
      <LineId Id="1090" Count="0" />
      <LineId Id="1038" Count="2" />
      <LineId Id="1042" Count="10" />
      <LineId Id="36" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>